\chapter*{Abstract}

The Internet-of-Things (IoT) is an ever growing network of devices connected to the Internet. Such devices are heterogeneous in their protocols and computation capabilities. With the rising computation and connectivity capabilities of these devices, the possibilities of their use in IoT systems increases. Concepts like smart cities are the current pinnacle of the use of these systems, which will involve a big amount of different devices in different conditions.

There are several tools for building complex IoT systems; some of these tools have different levels of expertise required and employ different architectures. One of the most popular is Node-RED. It provides users with a visual data flow architecture, with the side effect of making it accessible for a non-developer as well.

Most of these mainstream tools employ centralized methods of computation where a main component --- usually hosted in the cloud --- executes most of the computation on data provided by edge devices, \emph{e.g.} sensors and gateways. There are multiple consequences to this approach: (a)~edge computation capabilities are being neglected, (b)~it introduces a single point of failure, and (c)~local data is transferred across boundaries (private, technological, political...) either without need, or even in violation of legal constraints. Particularly, the principle of Local-First --- \emph{i.e.}, data and logic should reside locally, independent of third-party services faults and errors --- is blatantly ignored.

Previous works in the domain of visual programming attempt to mitigate some of these consequences, going as far as to propose solutions to decentralize flows and their execution in fog/edge devices. But they mostly require that the decomposition and partitioning effort to be manually specified by the developer when building the system, limiting dynamic adaptation of the system to failures or appearance of devices.

In this work we propose a method for extending Node-RED to allow the automatic decomposition and partitioning of the system towards higher decentralization. With this in mind, we implemented custom firmware for exposing the resources of the available devices, as well as new \textit{nodes} and modification in Node-RED that allow orchestration of tasks. This firmware is responsible for low-level management of health and capabilities, as well as executing MicroPython scripts on demand. Node-RED was modified to take advantage of this firmware by (1) implementing a device registry that allows devices to announce themselves, (2) generating MicroPython code from \textit{flow} and \textit{nodes} and (3) assigning \textit{nodes} to devices based on pre-specified properties and priorities. Likewise, a mechanism was developed to automatically detect abnormal run-time conditions, providing dynamic self-adaptation.

Our solution was tested by implementing home automation scenarios, where several experiments were made with the use of both virtual and physical devices. Several metrics were measured to allow understanding the impact on the resiliency, efficiency and elasticity of the system. With this data, we were able to conclude that our approach scales in terms of number of devices and is more robust. We further identified remaining open challenges to be tackled in the future.

\vspace*{10mm}\noindent

\textbf{Keywords}: Internet-of-Things, Orchestration, Visual Programming, Decentralized Computation, Large-Scale Systems

\begin{CCSXML}
    <ccs2012>
       <concept>
           <concept_id>10010520.10010553.10010562</concept_id>
           <concept_desc>Computer systems organization~Embedded systems</concept_desc>
           <concept_significance>500</concept_significance>
           </concept>
       <concept>
           <concept_id>10010520.10010521.10010537</concept_id>
           <concept_desc>Computer systems organization~Distributed architectures</concept_desc>
           <concept_significance>300</concept_significance>
           </concept>
       <concept>
           <concept_id>10010520.10010575.10010577</concept_id>
           <concept_desc>Computer systems organization~Reliability</concept_desc>
           <concept_significance>100</concept_significance>
           </concept>
       <concept>
           <concept_id>10011007.10010940.10010971.10010564</concept_id>
           <concept_desc>Software and its engineering~Embedded software</concept_desc>
           <concept_significance>300</concept_significance>
           </concept>
       <concept>
           <concept_id>10011007.10011006.10011066.10011069</concept_id>
           <concept_desc>Software and its engineering~Integrated and visual development environments</concept_desc>
           <concept_significance>100</concept_significance>
           </concept>
     </ccs2012>
    \end{CCSXML}

\chapter*{Resumo}

A Internet-of-Things (IoT) é uma rede de dispositivos conectados à Internet em constante crescimento. Estes dispositivos são heterogéneos nos seus protocolos e capacidades de computação. Com o crescimento das capacidades de computação e conectividade destes dispositivos, as possibilidades do seu uso em sistemas IoT aumentaram. Conceitos como Cidades Inteligientes são o pináculo do uso destes sistemas, que envolverão um grande número de dispositivos diferentes em diferentes condições.

Existem várias ferramentas para construir sistemas IoT; algumas destas ferramentas requerem diferentes níveis de perícia e usam diferentes arquiteturas. Uma das ferramentas mais populares é Node-RED. Esta permite aos seus utilizadores construir sistemas usando uma arquitetura visual de \emph{data flow}, tornando o processo mais fácil para um utilizador não programador.

No entanto, a maioria das ferramentas convencionais usam métodos centralizados de computação, onde um componente principal - normalmente alocado na \emph{cloud} - executa a maioria da computação nos dados provenientes dos dispositivos \emph{edge}, \emph{e.g.} sensores e \emph{gateways}. Esta abordagem tem diversas consequências: (a) capacidades de computação de dispositivos \emph{edge} estão a ser negligenciadas, (b) introduz um único ponto de falha, e (c) data local é transferida através de limites (privados, tecnológicos, políticos...) sem necessidade ou violando restrições legais. Especificamente, o princípio de \emph{Local-First} - \emph{i.e.}, dados e lógica devem residir localmente, independentemente de falhas e erros de serviços terceiros - é totalmente ignorado.

Trabalhos feitos no domínio de programação visual tentam mitigar algumas destas consequências, propondo uma solução que consiste na descentralização de \emph{flows} e a sua execução em dispositivos de \emph{fog} e \emph{edge}. Atualmente, para obter a este tipo de descentralização é necessário que o esforço de decomposição e partição seja manualmente efetuado pelo programador quando este constrói o sistema, limitando a adaptação dinâmica do sistema a falhas e ao aparecimento de dispositivos.

Neste documento propomos a extensão da ferramenta Node-RED para permitir a decomposição e partição automática do sistema com o fim de obter uma maior descentralização. Com isto em mente, implementámos \textit{firmware} personalizado que expõe os recursos dos dispositovos disponíveis, assim como novos nós e modificações no Node-RED que permitem a orquestração de tarefas. Este \textit{firmware} é responsável pela gestão em baixo-nível da saúde e capacidades do dispositivo, assim como a execução de código MicroPython sob demanda. Para aproveitar este \textit{firmware}, Node-RED foi alterado com (1) uma implementação de um registo de dispositivos que permite que estes se anunciem, (2) geração de código MicroPython a partir de \textit{flows} e nós e (3) alocamento de nós a dispositivos baseado em propriedades e prioridades pré-definidas. Para além disto, foi desenvolvido um mecanismo que deteta automaticamente condições anormais dos dispositivos em \emph{run-time}, levando o sistema a adaptar-se.

Para testar a nossa solução foram implementados cenários de \textit{home automation}, onde diversas experiências foram feitas usando dispositivos virtuais e físicos. Foram medidas várias métricas para permitir perceber o impacto na resiliência, eficiência e elasticidade do sistema. Com estes dados, pudemos concluir que a solução desenvolvida escala no número de dispositivos e é robusta. Foram identificados vários desafios por resolver, que ficam em aberto para trabalho futuro.

\vspace*{10mm}\noindent

\textbf{Keywords}: Internet of Things, Visual Programming, Edge Computing
