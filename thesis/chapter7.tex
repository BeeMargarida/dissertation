\chapter{Conclusions} \label{chap:concl} \minitoc

\section*{}


As the number of devices connected to the internet increases, it is important to leverage their capabilities and modify the way systems are built to take advantage of these resources. It is also important to allow end-users with no programming experience to build Internet-of-Things (IoT) systems, with the use of visual programming tools. These tools make the building process easier, reducing the knowledge of programming concepts needed.

Despite the existence of a considering number of visual programming tools applied to IoT, the majority of these tools are centralized. This centralization hinders the resiliency of the system, as the unit responsible for the execution of most or all of the computation is a single point of failure. If this unit or the network fails, the system stops being functional. Another issue of this type of architecture is the lack of usage of the computational capabilities of the rest of the devices in the system.

During the analysis of the state of the art, some issues and missing features were identified, which this dissertation aims to correct. The tools found that possess a decentralized architecture have limiting characteristics such as assumptions about what is a constrained device regarding computational capabilities, lack of open source licenses and simplification of the approach taken to the decomposition and assignment of tasks.

This dissertation aims to solve these issues by expanding an already popular visual programming tool, Node-RED, with a decentralized approach that focuses on leveraging all the devices, even ones that only support the execution of simple blocks of code. The expected result is a decentralized system that can self-adapt to run-time conditions and decomposes the given computations into independent tasks, which are assigned to devices. The assignment's goal is to increase the efficiency of the system, reducing latency and distributing CPU usage.  

\textcolor{blue}{Complete the conclusion with the conclusions from the evaluation}


\section{Difficulties}\label{sec:difficulties}

\textcolor{red}{Translate this}

\begin{itemize}
    \item Problemas de memória e espaço dos ESPs para execução de scripts de MicroPython com 3+ nós (ESPs lançam erros de alocamento de memória se o script enviado é maior que um certo nº de bytes ou ao fazer redeploy de scripts de médio tamanho). - Alternativas: failsafe (implementado e funcional), pyc (não existe para MicroPython mas existe o .mpy. No entanto, precisa de ser executado para gerar um .mpy a partir de um .pt, o que não se aplica à solução atual), ota (não existem boas soluções para MicroPython)
    \item Necessidade de implementar novos nós para situações de teste
    \item Node-red não suporta comunicação de mqtt entre nós de raíz. Node-red teve de ser adaptado para que a comunicação entre nós fosse feita desta maneira.
    \item Node-red implementation of subflows made it difficult to implement the MQTT communication to them
    \item Modificar scritps e suporte para o port para Unix do MicroPython - muitas diferenças, limitações e criação de muitos bugs.
    \item Limitações das bibliotecas usadas de MicroPython, especificamente nas bibliotecas de mqtt e operações assíncronas.
\end{itemize}{}

\section{Challenges}\label{sec:challenges}
\textcolor{red}{Translate this}
\begin{itemize}
    \item Como reorquestrar um sistema sem forçar o sistema a parar, isto é, garantindo availability (future work)
\end{itemize}

\section{Future Work}\label{sec:future_work}
\begin{itemize}
    \item Se calhar falhar um simples ping não devia levar a uma reorquestracao imediata, mas sim a mais ou ou outro ping para ter a certeza. Esses “retries” e o respectivo tempo podiam (1) ser configuráveis, ou até (2) serem baseados em cenas de confiança para as quais já há algoritmos bem definidos para isso em sistemas distribuídos.
    \item Reorquestrar o sistema sem forçar o sistema a parar, garantindo availability
    \item Suporte para outras linguagens e ports no code-generation e devices
    \item Suporte de code generation para outros nós
    \item Implementar lógica diferente de brute force para o alocamento de nós a dispositivos (knapsack ou assim)
\end{itemize}


\section{Contributions}

\section{Conclusions}