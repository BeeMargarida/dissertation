\chapter{State of the Art}\label{chap:sota}

\section*{}


\textcolor{yellow}{\textbf{**TEMP**}}


This chapter describes the state of the art in visual programming tools in Internet of Things context, as well as decentralized methods of work distribution in flow-based architectures. Section \ref{sec:slr} presents a systematic literature review on the topic of visual programming tools applied to the Internet of Things paradigm, which aims to answer the research questions defined in section \ref{sec:research_questions}. Section \ref{sec:slr_results} ...

\section{Systematic Literature Review}\label{sec:slr}

A Systematic Literature Review was made to gather information on the state of the art of visual programming applied to the Internet of Things paradigm. The goal of a systematic literature review is to synthesize evidence with emphasis on the quality of the it \cite{SLR_guidelines}.

\subsection{Methodology}\label{sec:methodology}

During this Systematic Literature Review, a specific methodology was followed to reduce bias and produce the best results \cite{SLR_guidelines}.
We started by defining the research questions to be answered as well as choosing data sources to search for publications.

\subsubsection{Research Questions}\label{sec:research_questions}

\textcolor{red}{\textbf{**REVIEW**}}\\
In this Systematic Literature Review we intent to answer the following questions:
\\ \\
\textbf{RQ1: How did Visual Programming Languages and Internet of Things evolve over time?} Internet of Things is a paradigm with several years, but in the last few years it has been increasing in its applications, specifically with its integration with visual programming tools and environments. It is important to analyze the evolution of these concepts and their integration, to be able to compare with the state of the art.\\ \\
\textbf{RQ2: Methodologies implemented in Internet of Things with Visual Programming Languages?} With the integration of visual programming tools with Internet of Things, several methodologies were implemented for it to be possible and provide users with a better experience.\\ \\
\textbf{RQ3: What is the maintenance and resilience of a Visual Programming Language integrated with an IoT system?} Visual programming tools provide users a easy way of programming, with the use of visual elements and relations between them. However, this approach has downsides, such as difficulty in constructing and maintaining complex systems and high level programming that undermines efficiency and resilience.


\subsubsection{Databases}\label{sec:databases}

The publications retrieved during this research were retrieved from the following databases, which are considered good and reliable sources:

\begin{itemize}
    \item IEEE
    \item ACM
    \item Scopus
\end{itemize}{}

\subsubsection{Search Process}\label{sec:process}

To obtain results from the databases chosen, a research question was written with the union of the keywords "visual programming", "node-red", "dataflow" and intersection with the keyword "Internet of Things".

\noindent
\begin{lstlisting}[frame=none, numbers=none, backgroundcolor=\color{white},]
((vpl OR visual programming OR visual-programming) OR (node-red OR node red OR nodered) OR (data-flow OR dataflow)) AND (IoT OR internet of things OR internet-of-things)
\end{lstlisting}

The search was performed in October of 2019 and the results produced are the ones present in the table \ref{tab:slr_search_results}.

\captionsetup{belowskip=12pt,aboveskip=4pt}
\begin{table}[ht]
    \centering
    \caption{Systematic Literature Review search results per database}
    \begin{tabular}{| c | c | c |}
        \hline
        \textbf{Database} & \textbf{Total Results} & \textbf{Extracted Results}\\
        \hline
        IEEE & 410 & 379 \\
        \hline
        ACM & 171,768 & 2021 \\
        \hline
        Scopus & 540 & 500 \\
        \hline
    \end{tabular}
    \label{tab:slr_search_results}
\end{table}{}

\subsubsection{Inclusion Criteria}\label{sec:inclusion}

To be included in the results, all publications should respect the inclusion criteria. If one of the criteria were not checked, the publication would not be included in the results. The inclusion criteria are the following:

\begin{enumerate}
    \item On the topic of visual programming in internet of things;
    \item Includes sufficient explanation of the research findings;
    \item Publication year in the range between 2008 and 2019.
\end{enumerate}{}

\subsubsection{Exclusion Criteria}\label{sec:exclusion}

In addition to the inclusion criteria, all publications were analyzed in their compliance to the exclusion criteria. If any publication failed to comply with at least one of the exclusion criteria, it would not be included in the results. The exclusion criteria are the following:

\begin{enumerate}
    \item Has less than two (non-self) citations when more than five years old;
    \item Presents just ideas, tutorials, integration experimentation, magazine publications, interviews or discussion papers;
    \item Not in English.
\end{enumerate}{}

\subsubsection{Quality Assessment}\label{sec:quality_accessment}

In order to classify if a publication is relevant to the research field, 4 assessments were made in order to better facility the process. The quality assessments are the following:\\

\captionsetup{belowskip=12pt,aboveskip=4pt}
\begin{table}[ht]
    \centering
    \caption{Parameters for measuring the quality of a publication}
    \resizebox{\textwidth}{!}{%
    \begin{tabular}{| l | l |}
        \hline
        \textbf{Quality Assessment Query} & \textbf{Quality Indicator (0-2)}\\
        \hline
        Is the publication relevant to us? & BARELY-PARTIALLY-SATISFACTORILY \\
        \hline
        Does the publication include and define research objectives adequately? & NO-PARTIALLY-YES \\
        \hline
        Are limitations and challenges well defined? & NO-PARTIALLY-YES \\
        \hline
        Is the proposed contribution well described? & NO-PARTIALLY-YES \\
        \hline
    \end{tabular}
    }
    \label{tab:quality_assessment}
\end{table}{}

Each assessment was posed in the form of a questions, and to each question there were three possible answers, with a numeric value each. If a publication didn't address the assessment the value with be 0, if the assessments was partially addressed the value would be 1. If the assessment was successfully satisfied, the value would be 2. In the end, the sum of all the assessments would represent the quality of the publication.

\subsubsection{Evaluation Process}\label{sec:evaluation_process}

The evaluation process of the publications followed six steps with specific purposes:

\begin{enumerate}
    \item \textbf{Range:} Publications are evaluated on date range, between 2008 and 2019;
    \item \textbf{Relevance:} Title and abstract are scanned for relevance regarding the defined research field;
    \item \textbf{Inclusion:} Publications are assessed against inclusion and exclusion criteria. Any publications not meeting the full inclusion criteria are discarded as well as all publications failing to comply to any exclusion criteria;
    \item \textbf{Specificity:} Reading the publication to verify if it relates closely enough to the defined research field; 
    \item \textbf{Data:} Selected publications are analyzed for data related to the research questions and contribution details;
    \item \textbf{Publication quality:} Publications are assessed using quality criteria defined in Table \ref{tab:quality_assessment}.
\end{enumerate}{}

The results from the evaluation process can be seen in Table \ref{tab:evaluation_process_results}.

\captionsetup{belowskip=12pt,aboveskip=4pt}
\begin{table}[ht]
    \centering
    \caption{Publications per step}
    \resizebox{\textwidth}{!}{
    \begin{tabular}{| l | r | r |}
        \hline
        \textbf{Step} & \textbf{Nº of publications} & \textbf{Nº of excluded publications}\\
        \hline
        Search & 2698 & N/A\\
        \hline
        Duplicates & 2626 & 72\\
        \hline
        Exclusion/Inclusion criteria (Titles and Abstracts) & 65 & 2561\\
        \hline
        Exclusion/Inclusion criteria (Introduction and Conclusion) & 27 & 38\\
        \hline
    \end{tabular}
    }
    \label{tab:evaluation_process_results}
\end{table}{}

\subsection{Results}\label{sec:slr_results}

After analyzing the 27 publications, we organized them by categories. \cite{survey_vpl_iot} is a survey and the remaining 26 were frameworks or tools.
\par Regarding the survey, publication \cite{survey_vpl_iot} makes an in-dept review of 13 visual programming languages in the field of IoT, comparing them under four attributes: (1) programming environment, (2) license, (3) project repository and (4) platform support. The author concluded with some advantages of using visual programming languages, such as the ease of visualizing programming logic, useful for rapid development and less burden on handling syntax error. However, some negative aspects were also mentioned, being the large amount of time building simple IoT applications the most important one.
\par The remaining 26 articles are frameworks or tools of visual programming applied to IoT. One of the tool is repeated in two papers, which showcases its evolution. The frameworks are:

\begin{enumerate}
    \item Solution for connecting devices from different IoT platforms, using Flow Based Programming with Node-RED \cite{Belsa2018}, proposed by \textbf{Belsa et al}. Its motivation is based on the limitation imposed by the IoT platform on communication between components and extensibility. This hinders possibilities to interact with services provided by other platforms. To validate their solution, they implemented a use case in the domain of transportation and logistics, with a composed service that used five different types of applications. The developed tool offers access to available services in a centralized visual framework, where end-users can use them to build more complex applications.
    \item \textbf{Ivy} \cite{ivy} proposes the next step forward regarding visualization applied to IoT with a visual programming tool that uses immersive virtual reality to allow users to link devices, insert logic and visualize real-time data flows between real-world sensors and actuators. It provides the end users with an immersive virtual reality that allows them to visualize the data flow, access to debugging tools and real-time deployment. Each programming construct called node - data flow architecture - has a distinct shape and color, which makes it easier for the user to understand the system being built or debugged. The experiences made in order to validate the prototype were positive, with the participants being receptive to Ivy and indicating use cases for it.
    \item With the rise in number of devices and their applications, it is impossible for developers to predict the way end users will exploit the devices, how they will be arranged and for which objectives will they be used. The goal of this paper \cite{personalization_of_context_dependent_apps}, proposed by \textbf{Ghiani et al.}, is to build a set of tools that allow non-developer users to customize their own Web IoT applications with the use of trigger-actions rules. The proposed solution provides a web-based tool for specifying trigger-action rules using \textit{IFTTT} and a context manager middleware that is able to adapt to the context and events of the devices and apply rules to the system. In order to validate the developed tool, an example home automation application that displays sensor values and directly controls appliances was built. The results were for the most part positive, and the issues found are related to usability and visual clues.
    \item \textbf{ViSiT} \cite{visit} allows its end-users to use a jigsaw puzzle metaphor to implement a system of connected IoT objects. It provides a web-based visual tool connected with a web-service that generates an executable implementation of the jigsaw representation and transformation. Their goal is achievable by adapting model transformations used by software developers into understandable metaphors for non-developers to use. They validated the developed tool with a usability evaluation, which was overall positive, with a great percentage considering the tool useful and providing real-life scenarios where they could implement it.
    \item A framework for Ambient Assisted Living (AAL) using IoT technologies is proposed by \textbf{Valsamakis and Savidis} \cite{Valsamakis2017}, which allows for customized automation. It uses visual programming languages to facilitate their end users - carers, family, friends, elderly - to build and modify the automations. They built a visual programming framework that introduces smart objects grouping in tagged environments and real-time smart-object registration through discovery cycles. It runs on typical smart phones and tablets and is built in Javascript, allowing it to run in browsers. Their future work focuses on integrating different visual programming paradigms to fully accomplish the requirements of the end-user.
    \item \textbf{WireMe} \cite{wireme} is an intuitive solution for building, deploying and monitor IoT systems, built with non-developer end users in mind but also extensible for advanced users to built over it. The developed solution makes use of Scratch, a visual programming interface, to provide its users with a customizable dashboard where they can monitor and control their IoT system as well as program automation tasks. It has a Main Control Unit responsible for communicating the devices status to the dashboard via MQTT, which is programmable using their visual interface and Lua programming language. Their tool was validated by students around 16 years old and engineering students without programming experience. The results were not totally positive, with some students not being able to create the required simple logic. Future work consists improving programming blocks to become more intuitive.
    \item \textbf{VIPLE} \cite{viple}, Visual IoT/Robotics Programming Language Environment, is a new visual programming language and its correspondent visual environment. It provides an introduction to topics such as computing and engineering and tools for more practical domains like service-oriented computing and software integration. It focuses on complex concepts such as robot as a service (Raas) units and Internet of Intelligent Things (IoIT), while studying the programming issues of building systems classified as such. The developed tool is extremely powerful and has been tested and used in several universities since 2015. \textcolor{red}{CHECK THIS ONE, kinda bad}
    \item \textbf{Smart Block} \cite{smart_block} is a block-based visual programming language and visual programming environment applied to IoT systems, that allows non-developer users to build their own systems in an easier way. Their solution is specific to the home automation domain, like Smart Things. The language was designed using IoTa calculus, used to generalize Event-Condition-Action rules for home automation. The environment was built using Blockly, a client-side Javascript library for creating visual block languages. Future work for this project consist of expanding custom blocks for features such as device grouping and security, as well as extending the tool for other domains besides home automation.
    \item \textbf{PWCT} \cite{pwct} is a visual programming language applied to building IoT, Data Computing and Cloud Computing systems. Its goal consist of reducing the cost of development of these types of systems by providing an easy and more productive development tool. The language was designed to compete with text based languages such as Java and C/C++. It uses graphical elements to replace textual code and has 3 main layers: (1) the VPL layer, composed of graphical elements, (2) the middleware layers, responsible for connecting the VPL layer with the system's view, which is the (3) System Layer, responsible for dealing with the source code generated by the first layer. The created solution received positive feedback from the community, with more than 70,000 downloads and 93\% of user satisfaction.
    \item \textbf{DDF} \cite{ddf} is a Distributed Dataflow (DDF) programming model for IoT systems, leveraging resources across the Fog and the Cloud. They implemented a DDF framework extending Node-RED, which originally is a centralized framework. Their motivation comes from the possibility to develop applications from the perspective of Fog Computing, leveraging these devices for efficiency and reduced latency, since there is a big amount of resources such as edge devices and gateways in IoT systems. They evaluated their prototype using a small scale evaluation, which was positive. The results showed that their DDF framework provides an easy alternative for designing and developing distributed IoT systems, despite having some open issues such as not having a distributed discovery of devices and networks.
    \item \textbf{GIMLE} \cite{gimle}, Graphical Installation Modelling Language for IoT Ecosystems), is a visual language that uses general-purpose visual programming styles to model domain knowledge through expressive ontological requirements. The goal of this language is to fill the gap of modelling requirements on physical properties of IoT installations by proposing a novel process for configuring industrial installations. It makes use of flow-based and domain-based visual programming in order to separate the logical flow of the requirements from their details. The developed tool supports reuse within the models, which is useful due to the repetitive nature of industrial installations,but it still needs to clarify how it fits within the current practice and its use in production settings.
    \item The approach on Runtime Verification proposed by \textbf{Leotta et al.} \cite{runtime_verification} aims to assure the quality of an IoT system. It can be used for detecting bugs in systems during development and maintenance activities, as well as be adopted for monitoring deployed IoT systems. Runtime verification is a software analysis approach in which a running system is observed by monitoring relevant events and their associated information to verify against a given specification of the expected behavior. When efficiently implemented, the verification process can be executed before the deployment of the system, for detecting bugs during the development and maintenance activities, as well as after the deployment, in order to provide an additional level of protection against unforeseen events. The results of the runtime verification tool developed were positive, with 92  \% detection of the bugs injected into the system. For future work, they plan to automate the generation of trace expressions and scenarios, as well as compare their approach with testing.
    \item \textbf{DDFlow} \cite{ddflow} is a macro-programming abstraction that aims to provide efficient means to program high quality distributed apps for IoT.
    The authors refer a lack of solutions for complex IoT systems programming, causing developers to build their own systems, which leads to a lack of portability/extensibility and results in a lot of similar systems that do the same thing, but are “different” because they were created by different programmers. Developers use Node-Red to specify the application functionalities and DDFlow handles scalability and deployment. The authors describe DDFlow's goal as to allow developers to formulate complex applications without having to care about low-level network, hardware and coordination details. This is done by having the DDFlow accompanying runtime dynamically scaling and mapping the resources, instead of the developer. DDFlow gives developers the possibility to inject custom code on nodes and have custom logic, if the available nodes are not enough for some task.
    \item The tool proposed by \textbf{Kefalakis et al.} \cite{visual_paradigm_iot_solutions_development} consists of a visual environment that operates over the OpenIoT architecture and facilitates the development of IoT applications with minimal programming effort. Modeling IoT services with the developed tool is made by specifying a graph that corresponds to an IoT application, which can be validated and its code generated and enacted over the OpenIoT middleware platform. It aims to fill the gap of tools that provide support for the development and deployment of integrated IoT applications. The approach taken presents several advantages: (1) it leverages standards-based semantic model for sensor and IoT context, making it easier to be widely adopted, (2) it is based on web-based technologies which opens the possibilities of applications from developers and (3) it is open source. 
    \item The approach presented by \textbf{Eterovic et al.} \cite{vpl_uml} proposes an IoT visual domain specific modeling language based on UML, with technical and non-technical users in mind. The authors defend that, with the evolving nature of IoT, the future end user will be a common person, with no programming knowledge. To solve the problems this future brings, it is important to build a visual language easy enough to be understood by non-technical people but expansible enough to represent complex systems. To evaluate the proposed solution, they invited 11 users of different levels of UML expertise to model a simple IoT system with the developed language. The System Usability Score was positive, as well as the Tasks Success Rate. Despite the positive score, some future actions would be the testing of the language with a more complex task as well as the integration of advanced UML notations.
    \item \textbf{FRED} \cite{fred} is a Frontend for Node-RED, a development tool that makes it possible to host multiple Node-RED processes. It can be used to connect devices to cloud services, coordinate communication between devices, integrate services with each other or creating new web app APIs and applications. To provide all these features, FRED supports the ability to run flows for multiple users and all flows get fair access to CPU, memory and storage resources. It also provides secure access to flow editors and the flow runtime. The authors concluded that FRED is a useful tool for users learning about Node-RED and to rapidly prototype cloud-hosted applications.
    \item \textbf{WoTFlow} \cite{wotflow_dnr} is proposed as a cloud-based platform that aims to provide an execution environment for multi-user cloud environments and individual devices. It aims to take advantage of data flow programming, which allows parts of the flow to be executed in parallel in different devices. Based on this, the tool will take advantage of the ability to split and partition the flows and distribute them by edge devices and the cloud. The state of the developed tool was in the early stages, with future expansions based on the use of optimization heuristics, automatic partitioning based on calculated constraints, security and privacy.
    \item The approach on runtime monitoring of NodeJS applications, proposed by \textbf{Ancona et al.} \cite{runtime_monitoring}, makes use of the dynamic analysis framework Jalangi to detect errors that would be otherwise difficult to catch with other techniques. This paper investigate the use trace expressions in runtime monitoring, which are language and system agnostic through the notion of event domain and type. To implement runtime monitoring, the authors instrument the source code of the program that needs to be verified, adding a piece of code that is able to capture all the relevant events for the domain in use. On the other hand, they have a Prolog server implementing the operational semantics of trace expressions and offering a simple REST interface. The monitor and the server communicate through HTTP requests and responses, effectively implementing a runtime verification system. Future work consist of expanding the current features of logging and error detection into error recovery procedures.
    \item \textbf{Devify} \cite{devify} is a framework that implements a new software architecture based on a peer-to-peer network and interoperability between IoT devices. This framework is divided in three layers: Application Logic Layer, Broker Server Layer and the Web of Things Layer. The application layer provides a flow-based programming like runtime engine with an unidirectional data flow design. However, the flow-based component has only a single output port and single input port. The broker server implements the peer-to-peer networking, REST-style remote procedure call operations and a distributed hash table. Additionally, the Web of Things layer can make distribution possible by providing a service contract without exposing server-side implementation details. In conclusion, the authors propose a decentralized IoT software framework that provides the ability of secure data exchange between IoT devices autonomously without any centralized server. To achieve security wanted, they used Flowchain, a blockchain-based decentralized IoT platform developed by them.
    \item An extension to the tool Orcc\footnote{https://github.com/orcc/orcc}, by \textbf{Paller et al.} \cite{orcc_extension}, that adds new features that are specific for the IoT problem domain to a tool dedicated to dataflow programming. The features added to Orcc, a tool that generates source code from RVC-CAL actors and XDF networks,include the improvements on the graphical Data-Flow Language (DFL), novel code generator for heterogeneous platforms and the library of ready-made IoT components or actors. The main goal was to extend the XDF file to address the platform heterogeneity. Furthermore, the utilization of this tool in development is expected to increase the quality, to reduce the development costs of IoT applications. In conclusion, this is an ongoing research but it has a lot of manual work like creation of the XCF configuration file with the smart environment needs. \textcolor{red}{review this, its super confusing}
    \item An IoT-based GUI, proposed by \textbf{Besari et al.} \cite{mobile_apps_rpi} \cite{pre_mobile_apps_rpi}, that aims to control sensors and actuators in an IoT system using an android application, in which the users used a visual programming language to configure and interact with the IoT system. The system was tested with a Pybot, which is a robot that is programmable similarly to an IoT system, with sensors and actuators. After testing and evaluating the system, the authors came to a score of 72.917 (out of 100) for the Pybot software, which is considered “GOOD”. The overall acceptability of the system was “ACCEPTABLE”, which led the authors to consider the application accepted by users.
    \item \textbf{CharIoT} \cite{chariot} is an end-user programming environment that promises to unify and support the configuration of IoT environments. It provides three blocks of support: capturing higher-level events using virtual sensors, construction of automation rules with a visual overview of the current configuration and support for sharing configuration between end users using a recommendation mechanism. To enable the capturing of higher-level events, it was developed two types of virtual sensors. The programmed virtual sensor provides a more accessible and understandable abstractions (defining that a room is "cold" if temperature is below 20ºC). The demonstrated virtual sensors are more complex, requiring the user to provide demonstration of the occurrence and not occurrence of the event (for example, the event of someone knocking on the door and the absence of someone knocking on the door). This last one requires the training of a Random Forest classifier. This programming environment is similar to IFTTT but goes one step further, with smarter event capturing and reusing of configurations, allowing the end-user to build faster and more robust IoT installations.
    \item A new technology, proposed by \textbf{Desolda et al.} \cite{desolda}, using a tangible programming language which allows non-programmers to configure the behavior of the smart objects in order to create and customize the smart environments. The main goal was to create, with the developed technology, a scenario of a smart museum. The authors defend that a personalization of a smart environment cannot be limited by the synchronization of smart devices and it may require experts to build the narrative of them, much like a museum said that. With this in mind, they introduced custom attributes to assign semantics to involved objects, in order to empower and simplify the creation of event-condition-action rules. In conclusion, this is an ongoing research focus on developing a new technology with an interaction paradigm to allow domain experts in the creation of smart environments. In addition, the fact that this technology uses expensive material (tabletop surface as digital workspace) doesn’t allow a regular user to use it as stated in the introduction.
    \item An End User Development (EUD) tool, proposed by \textbf{Eun et al.} \cite{eud_platform}, that allows end users to develop their own personal applications. It uses the dataflow approach, which allows for a more generalized programming experience as well the facility to build more complex programs with simple modules. The proposed tool has three main components: Service Template Authoring Tool, Service Template Repository and Smartphone Application. The first one allows for the end user to build more complex methods using atomic templates (components with simple functionality, like opening a curtain if it receives a command). The Service Template Repository contains the proprietary atomic templates as well as ones built by the user. Lastly, the Smartphone Application runs and manages the applications built by the user, as well as their requirements and dependencies. The developed EUD tool was compared with \textit{IFTTT} and Zapier, other tools focused on end user development. \textit{IFTTT} and the developed tool are more similar, focusing on consumer development, IoT and Home, with Zapier focusing on business. Both Zapier and \textit{IFTTT} use the Triger-Action paradigm (TAP), which differs from the dataflow paradigm used in this paper's tool.
    \item \textbf{RHEA} \cite{rhea} is a framework whose purpose is to offer a unified extensible way for reactive applications to be developed with integration between different sources and middlewares, for example MQTT and ROS (Robot operating system). This is done by using a dataflow model. A user writes a program that will be translated into a dataflow graph. Using that graph, the framework will optimize parts of it and assign them to nodes (physical computation resources), which will be distributed across the available machines for execution. It also handles requirements like node placement, where specific nodes need to be placed in specific machines with specific skills. This framework can be useful in integrating data and building complex applications that integrate IoT and Robotics in a easy way. It facilitates the connection between different modules with several requirements and excuses the user of having to deal with asynchronous callbacks. It differentiates itself from other existing dataflow frameworks by allowing the use of other systems to execute tasks, having support for heterogeneity of hardware and the reactivity aspect of it.
\end{enumerate}

The mentioned frameworks and tools were divided into the following categories, according to several characteristics:

\begin{description}
    \item [Scope] Some tools have specific use cases in mind (\textit{e.g.} smart cities, Home automation, industry, etc). Therefore, knowledge of the scope of a tool is useful to assess if it solves a problem or fills a specific gap in the literature. Example values consist of \textit{smart cities, home automation, education, industry} or \textit{many}, if there is more than one. 
    \item [Architecture] Visual programming tools applied to the Internet of Things can have an centralized or decentralized architecture, based on their use of Cloud, Fog or Edge Computing architecture. Possible values are \textit{Centralized}, \textit{Decentralized} and \textit{Mixed}.
    \item [License] The license of a software or tool is essential in terms of its usability. Normally, an open-source software reaches a bigger user base and allows them to expand and contribute to it. Possible values are the name of the tool license or N/A if it does not have one.
    \item [Tier] IoT systems, as explained in Section \ref{sec:architectures} is composed of three tiers - \textit{Cloud}, \textit{Fog} and \textit{Edge}. A tool can interact in several of these tiers, which shapes the features it contains and how it is built.
    \item [Scalability] Defines how the tool or framework scales. It can be calculated based on metrics used to test the performance of the system. In this case we considered scalability in terms of number and different type of devices supported. Possible values are \textit{low}, \textit{medium}, \textit{high} or N/A, it case there is no sufficient information.
    \item [Programming] According to Downes and Boshernitsan \cite{vpls_survey} and also mentioned in Section \ref{sec:background_vpl}, visual programming languages can be classified in five categories: (1) Purely Visual languages, (2) Hybrid text and visual systems, (3) Programming-by-example systems, (4) Constraint-oriented systems and (5) Form-based systems. These classifications aren't mutually exclusive. It is important to know which type, so that might be possible to assess the type of experience the tool provides to the user and its architecture.
    \item [Web-based] Defines if the visual programming language and/or environment can be used in a browser. It is useful in terms of usability of the tool.
\end{description}

\captionsetup{belowskip=12pt,aboveskip=4pt}
\begin{table}[ht]
    \centering
    \caption{VPLs applied to IoT and their characteristics. Small circles (\textbullet) mean \textit{yes}, hyphens (-) means \textit{no information available}, empty means \textit{no} and asterisk (*) means more than one.}
    \resizebox{\textwidth}{!}{
    \begin{tabular}{| c | c | c | c | c | c | c | c |}
        \hline
        \textbf{Tool} & \textbf{Scope} & \textbf{Architecture} & \textbf{License} & \textbf{Tier}  & \textbf{Scalability} & \textbf{Programming} & \textbf{Web-based}\\
        \hline
        Belsa et al.\cite{Belsa2018} & * & Centralized & - & Cloud & High & Hybrid text and visual system & \textbullet \\
        \hline
        Ivy \cite{ivy} & * & Centralized & - & Cloud & Medium & Purely Visual language &  \\
        \hline
        Ghiani et al. \cite{personalization_of_context_dependent_apps} & Home Automation & Centralized & - & Cloud & Medium\textcolor{red}{CHECK} & Constraint-oriented system & \textbullet \\
        \hline
        ViSiT \cite{visit} & * & Centralized & - & Cloud & High & Hybrid text and visual systems & \textbullet \\
        \hline
        Valsamakis and Savidis \cite{Valsamakis2017} & Ambient Assisted Living & Centralized & - & Cloud & N/A & Hybrid text and visual system & \textbullet \\
        \hline
        WireMe \cite{wireme} & Education, Home Automation & Centralized & - & Cloud & N/A & Hybrid text and visual system &  \\
        \hline
        VIPLE \cite{viple} &  &  &  &  &  &  &  \\
        \hline
        Smart Block \cite{smart_block} &  &  &  &  &  &  &  \\
        \hline
        PWCT \cite{pwct} &  &  &  &  &  &  &  \\
        \hline
        DDF \cite{ddf} &  &  &  &  &  &  &  \\
        \hline
        GIMLE \cite{gimle} &  &  &  &  &  &  &  \\
        \hline
        Leotta et al. \cite{runtime_verification} &  &  &  &  &  &  &  \\
        \hline
        DDFlow \cite{ddflow} &  &  &  &  &  &  &  \\
        \hline
        Kefalakis et al. \cite{visual_paradigm_iot_solutions_development} &  &  &  &  &  &  &  \\
        \hline
        Eterovic et al. \cite{vpl_uml} &  &  &  &  &  &  &  \\
        \hline
        FRED \cite{fred} &  &  &  &  &  &  &  \\
        \hline
        WoTFlow \cite{wotflow_dnr} &  &  &  &  &  &  &  \\
        \hline
        Ancona et al. \cite{runtime_monitoring} &  &  &  &  &  &  &  \\
        \hline
        Devify \cite{devify} &  &  &  &  &  &  &  \\
        \hline
        Paller et al. \cite{orcc_extension} &  &  &  &  &  &  &  \\
        \hline
        Besari et al. \cite{mobile_apps_rpi} \cite{pre_mobile_apps_rpi} &  &  &  &  &  &  &  \\
        \hline
        CharIoT \cite{chariot} &  &  &  &  &  &  &  \\
        \hline
        Desolda et al. \cite{desolda} &  &  &  &  &  &  &  \\
        \hline
        Eun et al. \cite{eud_platform} &  &  &  &  &  &  &  \\
        \hline
        RHEA \cite{rhea} &  &  &  &  &  &  &  \\
        \hline
    \end{tabular}
    }
    \label{tab:evaluation_process_results}
\end{table}{}

\textcolor{red}{\textbf{**WIP**}}
\textcolor{blue}{explicar caracteristicas de classificação(DONE); fazer o quadro com tudo organizado;}



\subsection{Expanded Search}

\textcolor{yellow}{\textbf{**TODO**}}
\textcolor{blue}{verificar os surveys e tirar as tools de lá tmb}

\subsubsection{Expanded Results}

\subsection{Analysis and Discussion}

\textcolor{yellow}{\textbf{**TODO**}}

\subsubsection{Result Analysis}

\textcolor{yellow}{\textbf{**TODO**}}
\textcolor{blue}{Organizar os artigos por categorias?}

\subsubsection{Research Questions}

\textcolor{blue}{Responder às research questions com os resultados}

\subsection{Conclusions}

\textcolor{yellow}{\textbf{**TODO**}}

\section{Decentralized Architectures in Visual Programming Tools applied to the Internet of Things paradigm}

\textcolor{blue}{Colocar aqui os resumos sobre os artigos que li sobre decentralização, mais específicos ao meu tema}
\textcolor{red}{Ainda nao sei como organizar esta parte}

\section{Summary}

\textcolor{yellow}{\textbf{**TODO**}}

