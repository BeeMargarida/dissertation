\chapter{Evaluation} \label{chap:evaluation} \minitoc

\section*{}

This section evaluates how the solution developed proves the hypothesis proposed in Chapter \ref{chap:problem_statement}.

\textcolor{blue}{Complete...}

% First, an explanation of the scenarios will be made, as well as their relation to the features developed and their advantages. 

\section{Scenarios and Experiments}\label{sec:scenarios_experiments}

The testing of the proposed solution diverged in two different scenarios. The first simulates physical devices with the use of Docker containers running the Unix port of micropython, allowing the construction of scalable scenarios with minimal costs. The second scenario uses physical devices, such as ESP8266 and ESP32, connected to the same Wi-Fi.

\begin{enumerate}
    \item A room has 3 sensors that give temperature and humidity readings every minute. Thereâ€™s a virtual sensor that compares the results (of both temperature and humidity) and triggers depending on some configured thresholds. An AC uses those readings to decide (a) if it switches on/off, (b) its operating mode: cool, heat, and dehumidify. The Minimal Working System (MWS) consists in (a) one temperature sensor, (b) one humidity sensor, (c) one node capable of making the decision, and (d) working communication channels amongst them.
    \item 20 devices, where each device redirects its input to its output. \textcolor{red}{improve}
\end{enumerate}

The first scenario aims to test the features of the developed solution with a moderately simple Node-RED flow, taking advantage of the nodes developed for micropython code generation support. The second scenario allows the comparison of the developed solution to the already existing solutions.

\textcolor{red}{Refactor this enumeration, with some explaining of some terms}

\textbf{Scenario 1}:
\begin{enumerate}
    \item \textbf{Sanity check.} All tasks are simple readings and forwarding, no compensation or other fault-tolerance strategy. Each sensor does its own thing. Orchestration is centralized. We expect all roundtrips to take less than the smallest part that can be resolved (measurement capability, which we estimate to be <1s). This will be executed using both Docker containers and physical devices.
    \item \textbf{Re-orchestration.}
        \begin{itemize}
            \item \textbf{Experiment A.} MWS is achieved via multiple possible configurations by selective (provoked) device failure (fail-stop);
            \item \textbf{Experiment B.} Inconsistent device behaviour, e.g. appear and disappear in shorter intervals lower that the time needed for orchestrating convergence (OCT), that leads to activity impacting the MWS;
            \item \textbf{Experiment C.} With 4 devices, each one with different processing capabilities. During orchestration, some devices will develop an out-of-memory error because they can't process all the processing tasks assigned to them, specifically the size of the script given. The orchestrator decides to send less tasks to these devices. The system will converge in a working solution. \textit{This scenario will be implemented with a modified device script. When devices receive a script, it will generate a memory error if the length of the script passes a certain threshold. This simulates the memory constraints of devices when receiving a file to big.}
            \item \textbf{Experiment D.} With 4 devices, some of them have a memory leak with an unknown cause. After random time Random(t0,t1), these problematic devices stop working with an out-of-memory error. The orchestrator thinks that the devices can't handle the quantity of processing tasks assigned to them, so in the re-orchestration it will assign fewer tasks. Since these devices will always break, the orchestrator will eventually not consider these devices in the assignment of nodes. \textit{This scenario will be implemented with a modified device script that will trigger an out-of-memory error after a random period after executing the given tasks.}
            \item \textbf{Experiment E.} With 4 devices, there is a device that is sensitive to a particular node, which causes the device to give out an out-of-memory error. The orchestrator will potentially assign this node to the specific device. When the device gives out the out-of-memory error, the orchestrator will eventually converge in a solution where the node is not assigned to the particular device, and the system will converge.  \textit{These out-of-memory errors will be simulated with the use of a failure node that forces an \texttt{MemoryException} in the device.}
            \item \item \textbf{Experiment F.} With 50 devices, each second the device has a probability to fail. This failure can go from 0 to 10 seconds, randomly chosen. The orchestrator must deal with the random failure of the devices and re-orchestrate the system. This experiment is considered a stress test, causing repeated failures and forcing constant re-orchestration.
        \end{itemize}
        Verifies that:
        \begin{enumerate}
            \item \textbf{Restrictions (predicates) are enforced.} Check that possible configurations lead to solutions that enforce defined predicates;
                \begin{enumerate}
                    \item Temperature and humidity might coexist in the same, or in dedicated, devices;
                \end{enumerate}
            \item \textbf{Priorities are honored.} Check that all specified priorities were taken into account, and only violated if necessary;
                \begin{enumerate}
                    \item Priority is given to edge devices, but fog and cloud can be used;
                    \item Priority is given to the maximum level of decentralization, but some centralization can be used.
                \end{enumerate}
        \end{enumerate}
\end{enumerate}

\textbf{Scenario 2}:
With the use of 20 physical devices, both ESP8266 and ESP32, implement a line topology, where a message is sent to a starting device, that will propagate it to its output. All the devices implement this propagation logic, which results in the initial message reaching the end of the line. The propagation time is measured, starting when the message is sent and ending when the message reaches the last node.
This experience is implemented in several environments:
\begin{enumerate}
    \item \textbf{Node-RED original}. Runs the experiment in the original Node-RED, using the default option (events) as the communication channel between nodes.
    \item \textbf{Node-RED + MQTT}. Run the experiment in Node-RED, using MQTT as the communication channel between nodes.
    \item \textbf{Node-RED modified + Dockers (same host)} Runs the experiment in the modified version of Node-RED, with each node assigned to a different virtual device, running in a Docker container. The Docker containers are running the firmware created in a Unix micropython port. The virtual devices are in the same host machine running the MQTT server instance.
    \item \textbf{Node-RED modified + Dockers (different host)} Runs the experiment in the modified version of Node-RED, with each node assigned to a different virtual device, running in a Docker container. The Docker containers are running the firmware created in a Unix micropython port. The MQTT server instance is in a different host machine from the one running the virtual devices. All machines are connected through Wi-Fi.
    \item \textbf{Physical + MQTT} Runs the experiment in physical devices without the developed firmware. Each device runs a simple micropython script that executes the wanted behaviour, communicating by MQTT. No Node-RED is used.
    \item \textbf{Node-RED modified + MQTT + Physical + Firmware} Runs the experiment with the developed solution, with each node assigned to a different physical device running the developed micropython firmware. All communicating is made using MQTT.
\end{enumerate}

\section{Discussion}\label{sec:evaluation_discussion}

\textcolor{blue}{For each experiment, analyse the data and discuss the results - many graphs, more tables and lots of text - fun times and very little time!}

\subsection{Scenario 1}\label{sec:discussion_scenario1}

As mentioned previously, the first scenario consists of a system that controls an A/C. This system takes into account readings of 3 temperature and humidity sensors to define if the room's temperature is too hot, cold of humid and sends commands to the A/C with the respective actions. The Node-RED implementation of this system can be seen in Figure \ref{fig:scenario1_node_red}.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{scenario1.png}
\caption[Node-RED implementation of scenario 1]{Node-RED implementation of scenario 1}\label{fig:scenario1_node_red}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%% SC %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Sanity Check}

The first experiment made to the developed solution tested the overall functionality of the tool and its efficiency. Using 4 Docker containers with the micropython Unix port with the developed firmware, the scenario presented in Figure \ref{fig:scenario1_node_red} was partitioned and assigned evenly to them. The assignment can be observed in Figure \ref{fig:sanity_check_nr_nodes}, where it was allocated 9 nodes for each device.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{experiences/1-sanity_check/nr_nodes.pdf}
\caption[Number of nodes allocated to each device]{Number of nodes allocated to each device}\label{fig:sanity_check_nr_nodes}
\end{figure}

The usage of RAM was significant, varying from 60Kb to 200Kb, as it can be observed in Figure \ref{fig:sanity_check_alloc_ram}. The flash size, presented in Figure \ref{fig:sanity_check_flash_size}, only decreases around 150000 bytes, when the device receives a script to execute, This quantity matches the overall payload received by the devices, which can be consulted in Figure \ref{fig:sanity_check_last_payload}.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{experiences/1-sanity_check/alloc_ram.pdf}
\caption[Devices' allocated RAM]{Devices' allocated RAM}\label{fig:sanity_check_alloc_ram}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{experiences/1-sanity_check/flash_size.pdf}
\caption[Devices' flash size]{Devices' flash size}\label{fig:sanity_check_flash_size}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{experiences/1-sanity_check/last_payload.pdf}
\caption[Devices' payloads size]{Devices' payloads size}\label{fig:sanity_check_last_payload}
\end{figure}

The total time the devices are available can be consulted in Figure \ref{fig:sanity_check_uptime}. Since this scenario occurs without any device failure, the uptime is linear.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{experiences/1-sanity_check/uptime.pdf}
\caption[Devices' uptime]{Devices' uptime}\label{fig:sanity_check_uptime}
\end{figure}

Once the devices execute the script given to them, each node allocated to a device start to communicate with each other, publishing and consuming MQTT messages. To verify that the system works, the messages of all communicating topics were captured. This messages prove that the system works, since all nodes are receiving their inputs and producing outputs. The number of communications can be consulted in Figure \ref{fig:sanity_nr_communications}. As it can be observed, the number of communications in device \texttt{8f96fa542f8b} is bigger than any other. This is due to the fact that in this device two temperature-humidity nodes were allocated, which publish 3 messages, a number communication events bigger than any other node. The device \texttt{4b86a2021b77} contains the other temperature-humidity node.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{experiences/1-sanity_check/nr_communications.pdf}
\caption[Number of MQTT communications of each device]{Number of MQTT communications of each device}\label{fig:sanity_nr_communications}
\end{figure}

\textcolor{red}{Include node assignment of nodes? JSON? Or modify the node-red flow and say the device each node was assigned to?}

%%%%%%%%%%%%%%%%%%%%%% SC Phys %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Sanity Check with physical devices}

\textcolor{blue}{TODO}

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{experiences/1-sanity_check_phys/nr_nodes.pdf}
\caption[Number of nodes allocated to each device]{Number of nodes allocated to each device}\label{fig:sanity_check_phys_nr_nodes}
\end{figure}
    
    
\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{experiences/1-sanity_check_phys/alloc_ram.pdf}
\caption[Devices' allocated RAM]{Devices' allocated RAM}\label{fig:sanity_check_phys_alloc_ram}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{experiences/1-sanity_check_phys/flash_size.pdf}
\caption[Devices' flash size]{Devices' flash size}\label{fig:sanity_check_phys_flash_size}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{experiences/1-sanity_check_phys/last_payload.pdf}
\caption[Devices' payloads size]{Devices' payloads size}\label{fig:sanity_check_phys_last_payload}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{experiences/1-sanity_check_phys/uptime.pdf}
\caption[Devices' uptime]{Devices' uptime}\label{fig:sanity_check_phys_uptime}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%% Exp A %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Experiment A}

\textcolor{blue}{TODO}

%%%%%%%%%%%%%%%%%%%%%% Exp A Phys %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Experiment A with physical devices}

\textcolor{blue}{TODO}

%%%%%%%%%%%%%%%%%%%%%% Exp B %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Experiment B}

\textcolor{blue}{TODO}

%%%%%%%%%%%%%%%%%%%%%% Exp C %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Experiment C}

\textcolor{blue}{TODO}

%%%%%%%%%%%%%%%%%%%%%% Exp D %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Experiment D}

\textcolor{blue}{TODO}

%%%%%%%%%%%%%%%%%%%%%% Exp E %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Experiment E}

\textcolor{blue}{TODO}

%%%%%%%%%%%%%%%%%%%%%% Exp F %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Experiment F}

\textcolor{blue}{TODO}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Scenario 2}\label{sec:discussion_scenario2}

As mentioned previously, several experiences were made to compare the developed solution to existing ones. To this end goal, a simple experiment of passing a message through several devices was implemented and the time the message takes to pass through all the devices was measured. The implementation of the scenario in the Node-RED tool is shown in Figure \ref{fig:scenario2_node_red}. The \textit{nothing} nodes execution consists of only redirecting their input to their output. The message consisting of the current timestamp is inserted into the system by the \textit{inject} node with user input, and the same message is showcased by the \textit{debug} node, the green one.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{scenario2.png}
\caption[Node-RED implementation of scenario 2]{Node-RED implementation of scenario 2}\label{fig:scenario2_node_red}
\end{figure}

This same setup was replicated in several environments, as mentioned before. Each experiment was replicated 10 times, resulting in the data seen in the Appendix \ref{ap:scenario2_tables} tables. These tables were analysed to construct the Table \ref{tab:scenario2_table} and its visually representation in Figure \ref{fig:scenario2_candlestick}.

\captionsetup{belowskip=12pt,aboveskip=4pt}
\begin{table}[ht]
    \centering
    \resizebox{0.8\textwidth}{!}{%
    \begin{tabular}{ l  c  c  c  c }
        \toprule
        \textbf{Label} & \textbf{Min} & \textbf{Q2} & \textbf{Q3} & \textbf{Max}\\
        \midrule
        Node-RED original & 3 & 10 & 13.25 & 15 \\
        Node-RED + MQTT & 134 & 430.5 & 711.25 & 883 \\
        Node-RED modified + Dockers (same host) & 1217 & 1318 & 1573.75 & 1665 \\
        Node-RED modified + Dockers (different host) & 1445 & 2536 & 2708 & 3059 \\
        Physical + MQTT & 3616 & 4142 & 4372 & 4452 \\
        Node-RED modified + MQTT + Physical + Firmware & 4168 & 4569 & 5087.75 & 5940 \\
        \bottomrule
    \end{tabular}
    }
    \caption{Scenario 2 results}
    \label{tab:scenario2_table}
\end{table}{}

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{scenario2_graph.pdf}
\caption[Scenario 2 results]{Scenario 2 results}\label{fig:scenario2_candlestick}
\end{figure}

The Figure \ref{fig:scenario2_candlestick} demonstrates that the developed solution is considerably less efficient in communicating message between nodes. However, given the other experiences, it is possible to conclude that this lack of efficiency is caused not by the firmware created but because of the stack of communication the message as to go through, as well as the nature of micropython. 

When the decentralization is applied inside Node-RED, without running any micropython, it is possible to see that the introduction of a Mosquitto broker running in the same host causes some latency. The introduction of Dockers running the firmware in the same host as the Node-RED instance and Mosquitto broker causes more latency, making it possible to conclude that micropython of the developed firmware also delay de communication. By repeating the same experience as before but with the Mosquitto broker in another machine, it is noticeable that the times are more spread out and the overall latency of the system is bigger. Given the stacks of Wi-Fi that the message as to go through, this result is logical.

Lastly, the experiment was repeated in physical devices, first by running a simple code in he micropython flashed devices and insertion of the message using the Mosquitto client, and second by using the whole developed system, with the modified Node-RED and firmware in the devices. The results allows us to conclude that the devices produce the worst time, but firmware developed introduces little latency, visible by the comparison of both their results.

It is possible to conclude that the developed solution's node communication is slower than the original Node-RED mostly due to the nature of Wi-Fi communications and the micropython port used.   

\textcolor{red}{Add other tables with the timestamps in the annex}

\subsection{Overview}\label{sec:discussion_overview}

\textcolor{blue}{Overview of the evaluation of the system, with conclusions of the evaluation of the system as a whole}

\section{Conclusions}\label{sec:evaluation_conclusions}

